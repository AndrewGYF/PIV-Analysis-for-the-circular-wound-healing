# PIV Analysis for the circular wound healing
This repository includes the MATLAB script, the raw data, and the TIF. images that are required to reproduce PIV results regarding the circular wound healing. 
## User Manual for the MATLAB Script
Based on the position data $(x,y)$, velocity data $(v_x, v_y)$ at each point, and the wound boundary given as a signed distance function (SDF) for each time frame (4hr, 12hr, 24hr) in the MATLAB file, we can calculate several 2D strain rate fields. These include:

- Radial strain rate (normal to the wound edge)

- Circumferential strain rate (tangential to the wound boundary)

- Divergence (which indicates tissue expansion or growth)

- Deviatoric strain rate (representing shear deformation)

The MATLAB script generates field plots for each of these quantities at every time frame. This allows us to visualize and analyze both local and global tissue behavior throughout the wound healing process.
1. One should make sure that both the MATLAB file (summarizing position data, velocity data, as well as the wound boundary information in terms of the sign distance function (SDF)), as well as the TIF. images are in the current folder while running the script. The `dir` function is going to detect and hence employ those TIF. images in the current file:
```matlab
tifFiles = dir('*.tif');
```
One can access those TIF. images by this link (coming soon).

2. Users will need to define the parameters in the command window once they run the script:
```matlab
%% User-defined input for new parameters
M = input('Enter the bin number M: ');
diff_order = input(['Enter the differential order n for' ...
    ' central difference (e.g., 1, 2, 3): ']);
epsilon = input('Enter the epsilon value: ');
```
where the wound region is divided into `M` regions of the same width, i.e.,$100$ micrometer, by $M+1$ contuors based on the SDF (in order to preserve the geometry of the wound shape), `diff_order` suggests the increment for the numerical derivatives, and $\varepsilon$ suggests the distance by which a contour is pushed back from the wound boundary. In our simulation, we set the bin number to be nine, the differential order to be 4 (the optimized resolution that can get rid of noises and exhibit a pattern for us to analyze the wound healing behavior), and $\varepsilon$ to be 20 $\mu m$. By dividing the wound region into `M` areas of the same width, we can compute the average value of those physical quantities, i.e., all types of strain rate and divergence for each area. By computing the average distance of each area with respect to the wound center, the script also plots those average physical quantities versus the average distance plots. We push the wound boundary back by $\varepsilon$ due to the fact that the velocity data generated by the PIVlab might have more errors at the wound front.
## 3. Numerical Implementation of those physical quantities (for those who are interested)
We define the wound contour using the sign distance function (SDF); that said, it is inside the wound if $SDF<0$, and it is outside the wound if $SDF\geq 0$. To quantify the wound healing process discussed in the previous section, we implement numerical derivatives to determine the velocity gradient, denoted by $\partial_{(x,y)}(u,v)$, at each location outside the wound region, i.e., $SDF\geq 0$. Suppose the velocity profile at each location $(i,j)$ outside the wound region is denoted by $(u_{i},v_{j})$. Recall that the spatial increment is given by $nh$, where $n$ is suggested by `diff_order` and $h=\Delta x=\Delta y$. In this regard, for each $(i,j)$, its neighbors are $(i,j-n)$ and $(i,j+n)$ (horizontal case)/$(i-n,j)$ and $(i+n,j)$. If two neighbors of $(i,j)$ are all in the region characterized by $SDF\geq0$, then we employ the central difference approximation to compute the numerical derivative, i.e., $\partial_{x} u(i,j)\approx (u(i,j+1)-u(i,j-1))/2nh$. If $(i,j)$ and one of its neighbors are in the region suggested by $SDF\geq 0$, we implement either forward difference approximation or backward difference approximation, i.e., $\partial_{x} u(i,j)\approx (u(i,j+1)-u(i,j))/nh$ if $(i,j)$'s neighbor are on its right hand side, and $\partial_{x} u(i,j)\approx (u(i,j)-u(i,j-1))/nh$ if $(i,j)$'s neighbor are on its left hand side. Such an algorithm applies to all numerical derivatives, i.e., $\partial_{x}v$, $\partial_{y}u$, and $\partial_{y}v$.
```
% Initialize gradient matrices
    [ny, nx] = size(U_grid);
    du_dx = zeros(ny, nx);
    du_dy = zeros(ny, nx);
    dv_dx = zeros(ny, nx);
    dv_dy = zeros(ny, nx);

    % Calculate gradients with First Contour SDF-aware method using new epsilon
    for i = 1:ny
        for j = 1:nx
            % Current point SDF value
            current_sdf = SDF(i,j);
            
            %% Calculate du/dx
            if current_sdf < epsilon  % Use new epsilon
                % Point inside first contour - set gradient to NaN
                du_dx(i,j) = NaN;
            else
                % Point outside first contour - check neighbors
                left_j = j - diff_order;
                right_j = j + diff_order;
                
                % Check if neighbors are within grid boundaries AND in SDF>=epsilon_new region
                left_valid = (left_j >= 1) && (left_j <= nx) && (SDF(i, left_j) >= epsilon);
                right_valid = (right_j >= 1) && (right_j <= nx) && (SDF(i, right_j) >= epsilon);
                
                if left_valid && right_valid
                    % Both neighbors valid - use central difference
                    du_dx(i,j) = (U_grid(i, right_j) - U_grid(i, left_j)) / (2 * diff_order * h_x);
                elseif right_valid
                    % Only right neighbor valid - use forward difference
                    du_dx(i,j) = (U_grid(i, right_j) - U_grid(i, j)) / (diff_order * h_x);
                elseif left_valid
                    % Only left neighbor valid - use backward difference
                    du_dx(i,j) = (U_grid(i, j) - U_grid(i, left_j)) / (diff_order * h_x);
                else
                    % No valid neighbors - cannot compute gradient
                    du_dx(i,j) = NaN;
                end
            end
            
            %% Calculate du/dy
            if current_sdf < epsilon  % Use new epsilon
                % Point inside first contour - set gradient to NaN
                du_dy(i,j) = NaN;
            else
                % Point outside first contour - check neighbors
                bottom_i = i - diff_order;
                top_i = i + diff_order;
                
                % Check if neighbors are within grid boundaries AND in SDF>=epsilon_new region
                bottom_valid = (bottom_i >= 1) && (bottom_i <= ny) && (SDF(bottom_i, j) >= epsilon);
                top_valid = (top_i >= 1) && (top_i <= ny) && (SDF(top_i, j) >= epsilon);
                
                if bottom_valid && top_valid
                    % Both neighbors valid - use central difference
                    du_dy(i,j) = (U_grid(top_i, j) - U_grid(bottom_i, j)) / (2 * diff_order * h_y);
                elseif top_valid
                    % Only top neighbor valid - use forward difference
                    du_dy(i,j) = (U_grid(top_i, j) - U_grid(i, j)) / (diff_order * h_y);
                elseif bottom_valid
                    % Only bottom neighbor valid - use backward difference
                    du_dy(i,j) = (U_grid(i, j) - U_grid(bottom_i, j)) / (diff_order * h_y);
                else
                    % No valid neighbors - cannot compute gradient
                    du_dy(i,j) = NaN;
                end
            end
            
            %% Calculate dv/dx
            if current_sdf < epsilon  % Use new epsilon
                % Point inside first contour - set gradient to NaN
                dv_dx(i,j) = NaN;
            else
                % Point outside first contour - check neighbors
                left_j = j - diff_order;
                right_j = j + diff_order;
                
                % Check if neighbors are within grid boundaries AND in SDF>=epsilon_new region
                left_valid = (left_j >= 1) && (left_j <= nx) && (SDF(i, left_j) >= epsilon);
                right_valid = (right_j >= 1) && (right_j <= nx) && (SDF(i, right_j) >= epsilon);
                
                if left_valid && right_valid
                    % Both neighbors valid - use central difference
                    dv_dx(i,j) = (V_grid(i, right_j) - V_grid(i, left_j)) / (2 * diff_order * h_x);
                elseif right_valid
                    % Only right neighbor valid - use forward difference
                    dv_dx(i,j) = (V_grid(i, right_j) - V_grid(i, j)) / (diff_order * h_x);
                elseif left_valid
                    % Only left neighbor valid - use backward difference
                    dv_dx(i,j) = (V_grid(i, j) - V_grid(i, left_j)) / (diff_order * h_x);
                else
                    % No valid neighbors - cannot compute gradient
                    dv_dx(i,j) = NaN;
                end
            end
            
            %% Calculate dv/dy
            if current_sdf < epsilon  % Use new epsilon
                % Point inside first contour - set gradient to NaN
                dv_dy(i,j) = NaN;
            else
                % Point outside first contour - check neighbors
                bottom_i = i - diff_order;
                top_i = i + diff_order;
                
                % Check if neighbors are within grid boundaries AND in SDF>=epsilon_new region
                bottom_valid = (bottom_i >= 1) && (bottom_i <= ny) && (SDF(bottom_i, j) >= epsilon);
                top_valid = (top_i >= 1) && (top_i <= ny) && (SDF(top_i, j) >= epsilon);
                
                if bottom_valid && top_valid
                    % Both neighbors valid - use central difference
                    dv_dy(i,j) = (V_grid(top_i, j) - V_grid(bottom_i, j)) / (2 * diff_order * h_y);
                elseif top_valid
                    % Only top neighbor valid - use forward difference
                    dv_dy(i,j) = (V_grid(top_i, j) - V_grid(i, j)) / (diff_order * h_y);
                elseif bottom_valid
                    % Only bottom neighbor valid - use backward difference
                    dv_dy(i,j) = (V_grid(i, j) - V_grid(bottom_i, j)) / (diff_order * h_y);
                else
                    % No valid neighbors - cannot compute gradient
                    dv_dy(i,j) = NaN;
                end
            end
        end
    end
```
Once we know the velocity gradient at $(i,j)$, we can compute the deviatoric strain rate as well as divergence at $(i,j)$, i.e., $\partial_{x}u(i,j)+\partial_{y}v(i,j)$ (divergence), the maximum eigenvalue of $1/2($velocity gradient$(i,j)+$ velocity gradient$^{T}(i,j)-$ divergence$(i,j))$ (deviatoric strain rate). 
```
    div_velocity = du_dx + dv_dy;
    
    %% Compute Deviatoric Strain Rate (Max. eignevalue)
    fprintf('  Computing deviatoric strain rate (max eigenvalue of ∇v - div(v)I)...\n');
    
    % Initialize Deviatoric Strain Rate Matrix
    deviatoric_strain_rate = NaN(ny, nx);
    
    % Identity Matrix
    I = eye(2);
    
    % Computing Deviatoric Strain Rate
    for i = 1:ny
        for j = 1:nx
            % (not NaN and in the region SDF >= epsilon）
            if ~isnan(du_dx(i,j)) && ~isnan(du_dy(i,j)) && ...
               ~isnan(dv_dx(i,j)) && ~isnan(dv_dy(i,j)) && ...
               ~isnan(div_velocity(i,j))
                
                % Construct Velocity Gradient Matrix 
                grad_v = [du_dx(i,j), du_dy(i,j);
                          dv_dx(i,j), dv_dy(i,j)];
                
                % Compute \nabla v - div(v)I
                A = 0.5 * (grad_v + (grad_v)' - div_velocity(i,j) * I);
                
                % Compute eigenvalue
                eig_vals = eig(A);
                
                % Take Max. eigenvalue as the Deviatoric Strain Rate
                if ~isempty(eig_vals)
                    real_vals = real(eig_vals);
                    deviatoric_strain_rate(i,j) = max(real_vals);
                end
            end
        end
    end
```
