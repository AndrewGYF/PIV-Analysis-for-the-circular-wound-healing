# PIV Analysis for the circular wound healing
This repository includes the MATLAB script, the raw data, and the TIF. images that are required to reproduce PIV results regarding the circular wound healing. 
## User Manual for the MATLAB Script
Provided the position data, i.e., $(x,y)$, the velocity data at each position, i.e., $(v_{x},v_{y})$, as well as the wound boundary in terms of the sign distance function (SDF) for each time frame, i.e., 4hr, 12hr, 24hr, in the MATLAB file, we can compute the radial strain rate (strain rate that is normal to the wound contour), circumferential strain rate (strain rate that is tangential to the wound boundary), divergence (a measure of tissue growth), as well as deviatoric strain rate (shear strain rate) $2D$ field plots at each time slot such that we can characterize and visualize its both local and global behaviors for the wound-healing process. Below shows how the MATLAB script achieves such a goal.
1. One should make sure that both the MATLAB file (summarizing position data, velocity data, as well as the wound boundary information in terms of the sign distance function (SDF)), as well as the TIF. images are in the current folder while running the script. The `dir` function is going to detect and hence employ those TIF. images in the current file:
```matlab
tifFiles = dir('*.tif');
```
One can access those TIF. images by this link (coming soon).

2. Users will need to define the parameters in the command window once they run the script:
```matlab
%% User-defined input for new parameters
M = input('Enter the bin number M: ');
diff_order = input(['Enter the differential order n for' ...
    ' central difference (e.g., 1, 2, 3): ']);
epsilon = input('Enter the epsilon value: ');
```
where the wound region is divided into `M` regions of the same width, i.e.,$100$ micrometer, by $M+1$ contuors based on the SDF (in order to preserve the geometry of the wound shape), `diff_order` suggests the increment for the numerical derivatives, and $\varepsilon$ suggests the distance by which a contour is pushed back from the wound boundary. In our simulation, we set the bin number to be nine, the differential order to be 4, and $\varepsilon$ to be 20 $\mu m$. By dividing the wound region into `M` areas of the same width, we can compute the average value of those physical quantities, i.e., all types of strain rate and divergence for each area. By computing the average distance of each area with respect to the wound center, the script also plots those average physical quantities versus the average distance plots. We push the wound boundary back by $\varepsilon$ due to the fact that the velocity data generated by the PIVlab might have more errors at the wound front.
## 3. Numerical Implementation of those physical quantities (for those ones who are interested in)
```
% Initialize gradient matrices
    [ny, nx] = size(U_grid);
    du_dx = zeros(ny, nx);
    du_dy = zeros(ny, nx);
    dv_dx = zeros(ny, nx);
    dv_dy = zeros(ny, nx);

    % Calculate gradients with First Contour SDF-aware method using new epsilon
    for i = 1:ny
        for j = 1:nx
            % Current point SDF value
            current_sdf = SDF(i,j);
            
            %% Calculate du/dx
            if current_sdf < epsilon  % Use new epsilon
                % Point inside first contour - set gradient to NaN
                du_dx(i,j) = NaN;
            else
                % Point outside first contour - check neighbors
                left_j = j - diff_order;
                right_j = j + diff_order;
                
                % Check if neighbors are within grid boundaries AND in SDF>=epsilon_new region
                left_valid = (left_j >= 1) && (left_j <= nx) && (SDF(i, left_j) >= epsilon);
                right_valid = (right_j >= 1) && (right_j <= nx) && (SDF(i, right_j) >= epsilon);
                
                if left_valid && right_valid
                    % Both neighbors valid - use central difference
                    du_dx(i,j) = (U_grid(i, right_j) - U_grid(i, left_j)) / (2 * diff_order * h_x);
                elseif right_valid
                    % Only right neighbor valid - use forward difference
                    du_dx(i,j) = (U_grid(i, right_j) - U_grid(i, j)) / (diff_order * h_x);
                elseif left_valid
                    % Only left neighbor valid - use backward difference
                    du_dx(i,j) = (U_grid(i, j) - U_grid(i, left_j)) / (diff_order * h_x);
                else
                    % No valid neighbors - cannot compute gradient
                    du_dx(i,j) = NaN;
                end
            end
            
            %% Calculate du/dy
            if current_sdf < epsilon  % Use new epsilon
                % Point inside first contour - set gradient to NaN
                du_dy(i,j) = NaN;
            else
                % Point outside first contour - check neighbors
                bottom_i = i - diff_order;
                top_i = i + diff_order;
                
                % Check if neighbors are within grid boundaries AND in SDF>=epsilon_new region
                bottom_valid = (bottom_i >= 1) && (bottom_i <= ny) && (SDF(bottom_i, j) >= epsilon);
                top_valid = (top_i >= 1) && (top_i <= ny) && (SDF(top_i, j) >= epsilon);
                
                if bottom_valid && top_valid
                    % Both neighbors valid - use central difference
                    du_dy(i,j) = (U_grid(top_i, j) - U_grid(bottom_i, j)) / (2 * diff_order * h_y);
                elseif top_valid
                    % Only top neighbor valid - use forward difference
                    du_dy(i,j) = (U_grid(top_i, j) - U_grid(i, j)) / (diff_order * h_y);
                elseif bottom_valid
                    % Only bottom neighbor valid - use backward difference
                    du_dy(i,j) = (U_grid(i, j) - U_grid(bottom_i, j)) / (diff_order * h_y);
                else
                    % No valid neighbors - cannot compute gradient
                    du_dy(i,j) = NaN;
                end
            end
            
            %% Calculate dv/dx
            if current_sdf < epsilon  % Use new epsilon
                % Point inside first contour - set gradient to NaN
                dv_dx(i,j) = NaN;
            else
                % Point outside first contour - check neighbors
                left_j = j - diff_order;
                right_j = j + diff_order;
                
                % Check if neighbors are within grid boundaries AND in SDF>=epsilon_new region
                left_valid = (left_j >= 1) && (left_j <= nx) && (SDF(i, left_j) >= epsilon);
                right_valid = (right_j >= 1) && (right_j <= nx) && (SDF(i, right_j) >= epsilon);
                
                if left_valid && right_valid
                    % Both neighbors valid - use central difference
                    dv_dx(i,j) = (V_grid(i, right_j) - V_grid(i, left_j)) / (2 * diff_order * h_x);
                elseif right_valid
                    % Only right neighbor valid - use forward difference
                    dv_dx(i,j) = (V_grid(i, right_j) - V_grid(i, j)) / (diff_order * h_x);
                elseif left_valid
                    % Only left neighbor valid - use backward difference
                    dv_dx(i,j) = (V_grid(i, j) - V_grid(i, left_j)) / (diff_order * h_x);
                else
                    % No valid neighbors - cannot compute gradient
                    dv_dx(i,j) = NaN;
                end
            end
            
            %% Calculate dv/dy
            if current_sdf < epsilon  % Use new epsilon
                % Point inside first contour - set gradient to NaN
                dv_dy(i,j) = NaN;
            else
                % Point outside first contour - check neighbors
                bottom_i = i - diff_order;
                top_i = i + diff_order;
                
                % Check if neighbors are within grid boundaries AND in SDF>=epsilon_new region
                bottom_valid = (bottom_i >= 1) && (bottom_i <= ny) && (SDF(bottom_i, j) >= epsilon);
                top_valid = (top_i >= 1) && (top_i <= ny) && (SDF(top_i, j) >= epsilon);
                
                if bottom_valid && top_valid
                    % Both neighbors valid - use central difference
                    dv_dy(i,j) = (V_grid(top_i, j) - V_grid(bottom_i, j)) / (2 * diff_order * h_y);
                elseif top_valid
                    % Only top neighbor valid - use forward difference
                    dv_dy(i,j) = (V_grid(top_i, j) - V_grid(i, j)) / (diff_order * h_y);
                elseif bottom_valid
                    % Only bottom neighbor valid - use backward difference
                    dv_dy(i,j) = (V_grid(i, j) - V_grid(bottom_i, j)) / (diff_order * h_y);
                else
                    % No valid neighbors - cannot compute gradient
                    dv_dy(i,j) = NaN;
                end
            end
        end
    end

    % Store gradient data for this file
    gradient_data(file_idx).filename = preprocessed_data(file_idx).filename;
    gradient_data(file_idx).du_dx = du_dx;
    gradient_data(file_idx).du_dy = du_dy;
    gradient_data(file_idx).dv_dx = dv_dx;
    gradient_data(file_idx).dv_dy = dv_dy;
    gradient_data(file_idx).diff_order = diff_order;
    gradient_data(file_idx).M = M;
    gradient_data(file_idx).epsilon = epsilon;  % Store epsilon

    % Calculate angle theta for each point
    [dSDF_dx, dSDF_dy] = gradient(SDF);
    theta = atan2(dSDF_dy, dSDF_dx);  % atan2 gives angle in radians from -pi to pi
    
    % Calculate cos_theta and sin_theta
    cos_theta = cos(theta);
    sin_theta = sin(theta);

    div_velocity = du_dx + dv_dy;
    H_rr = du_dx.* (cos_theta).^2 + (du_dy + dv_dx).* cos_theta.* sin_theta + dv_dy.* (sin_theta).^2;
    H_theta_theta = du_dx.* (sin_theta).^2 - (du_dy + dv_dx).* cos_theta.* sin_theta + dv_dy.* (cos_theta).^2;
    tr_H = 0.5 * (H_rr + H_theta_theta);
    
    %% Compute Deviatoric Strain Rate (Max. eignevalue)
    fprintf('  Computing deviatoric strain rate (max eigenvalue of ∇v - div(v)I)...\n');
    
    % Initialize Deviatoric Strain Rate Matrix
    deviatoric_strain_rate = NaN(ny, nx);
    
    % Identity Matrix
    I = eye(2);
    
    % Computing Deviatoric Strain Rate
    for i = 1:ny
        for j = 1:nx
            % (not NaN and in the region SDF >= epsilon）
            if ~isnan(du_dx(i,j)) && ~isnan(du_dy(i,j)) && ...
               ~isnan(dv_dx(i,j)) && ~isnan(dv_dy(i,j)) && ...
               ~isnan(div_velocity(i,j))
                
                % Construct Velocity Gradient Matrix 
                grad_v = [du_dx(i,j), du_dy(i,j);
                          dv_dx(i,j), dv_dy(i,j)];
                
                % Compute \nabla v - div(v)I
                A = 0.5 * (grad_v + (grad_v)' - div_velocity(i,j) * I);
                
                % Compute eigenvalue
                eig_vals = eig(A);
                
                % Take Max. eigenvalue as the Deviatoric Strain Rate
                if ~isempty(eig_vals)
                    real_vals = real(eig_vals);
                    deviatoric_strain_rate(i,j) = max(real_vals);
                end
            end
        end
    end
```
One can refer to the PIV guide in the repository (coming soon). In addition, we compute the divergence plots for each time frame in order to observe the wound healing situation as time evolves.
